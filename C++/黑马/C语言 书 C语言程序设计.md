### 第一章 导言
.c写，a.out是cc hello.c之后生成的输出，可以直接执行
escape sequence 转义符 比如\\
tokens 令牌

````ad-question
title:为什么cc hello.c之后生成的是a.out?后缀和命名有没有讲究？
关于为什么选择`a.out`作为默认名称，有一些历史背景：

1. **Unix历史**: 在早期的Unix系统中，当编译器生成机器代码时，默认的输出文件名是`a.out`。其中，“a”代表“assembly”（汇编），因为在生成这个文件之前，源代码首先被转化为汇编语言。`.out`是一个表示“output”的后缀。
    
2. **简单的默认值**：当开发者没有明确指定输出文件的名称时，这为他们提供了一个简单、易于记忆的默认文件名。
    

如果你想生成一个具有不同名称的输出文件，你可以使用`-o`选项来指定新的名称。例如：
```python
cc hello.c -o hello
```
这会将编译后的程序保存为名为`hello`的文件。

至于文件命名和后缀的讲究，通常，Unix和Linux的可执行文件没有文件扩展名，与Windows中的`.exe`扩展名不同。但是，命名通常与该程序或工具的功能有关，使其更有描述性。例如，`ls`, `grep`, `awk`等都是Unix/Linux命令行工具的名称，它们的名称与它们的功能直接相关。
````
> C里面不用缩进，缩进主要为了可读性
> 在 C 语言中，所有变量都必须先声明后使用。声明通常放在函数起始处，在任何可执行 语句之前。声明用于说明变量的属性，它由一个类型名和一个变量表组成

```ad-note
title:基本数据类型
int 整型（int还可以存EOF）
float 浮点型
char 一个字节
short 短整型
long 长整形
double 双精度浮点型
```
> int 与 float 类型的取值范围取决于具体的机器。对于 int 类型， 通常为 16 位，其取值范围在-32768～32767 之间，也有用 32 位表示的 int 类型。float 类 型通常是 32 位，它至少有 6 位有效数字，取值范围一般在 10-38 ～10 38 之间。
> <span style="color:red">int可以存储整数，也可以存字符，因为内部是ASCII或Unicode，有对应整数。</span>
```python
int main() {
    int x = 'A'; // 'A' 在ASCII中对应的整数值是 65
    printf("%d\n", x); // 将输出 65
    printf("%c\n", x); // 将输出 A
    return 0;
}
```

```ad-note
title:舍位
在该程序中，绝大部分工作都是在循环体中完成的。循环体中的赋值语句
`celsius = 5 * (fahr - 32) / 9` 
用于计算与指定华氏温度相对应的摄氏温度值，并将结果赋值给变量 celsius。在该语句中， 之所以把表达式写成先乘 5 然后再除以 9 而不是直接写成 5 / 9，其原因是在 C 语言及许多 其它语言中，整数除法操作将执行舍位，结果中的任何小数部分都会被舍弃。由于 5 和 9 都 是整数，5 / 9 相除后经截取所得的结果为 0，因此这样求得的所有摄氏温度都将为 0。
```

```ad-note
title: 前缀运算符/后缀运算符
++nc
nc++
nc = nc + 1
```

```ad-question
title:为什么16位存储单元最大值为32767
符号，0，so 2**15-1=32767
p.s.一个字符是8个字节
```

```ad-note
title:占位符
printf("%d", i)
其中的每个百分号（%） 表示其它的参数（第二个、第三个、……参数）之一进行替换的位置，并指定打印格式。
- %d  按照十进制整型数打印
- %6d 按照十进制整型数打印，至少 6 个字符宽
- %6.2f 按照浮点数打印，至少 6 个字符宽，小数点后有两位小数
- %o 八进制数
- %x 十六进制数
- %c 字符
- %s 字符串
- \%%表示百分号（%）本身。
```

```ad-note
title:函数
函数定义的一般形式为：
	返回值类型 函数名(0个或多个参数声明) 
{
	声明部分 
	语句序列
}
```
> 我们通常把函数定义中圆括号内列表中出现的变量称为形式参数，而把函数调用中与形 式参数对应的值称为实际参数。
> 由于 main 本身也是函数， 因此main 函数也可以向其调用者返回一个值，该调用者实际上就是程序的执行环境。一般来说，返回值为 0 表示正常终止，返回值为非 0 表示出现异常情况或出错结束条件。

```ad-note
title:局部变量
1. 函数内部中的变量是局部变量（私有变量，自动变量），其他函数不能直接访问
2. 函数中的每个局部变量只在函数被调用时存在，在函数执行完毕退出时消失。
```
> main 函数中的变量（如 line、longest 等）是 main 函数的私自变量或局部变量。由 于它们是在 main 函数中声明的，因此其它函数不能直接访问它们

```ad-note
title:外部变量
除自动变量外，还可以定义位于所有函数外部的变量，也就是说，在所有函数中都可以通过变量名访问这种类型的变量（这机制同 Fortran 语言中的 COMMON 变量或 Pascal 语言中最外层程序块声明的变量非常类似）。由于外部变量可以在全局范围内访问，因此，函数间可以通过外部变量交换数据，而不必使用参数表。再者，外部变量在程序执行期间一直存在，而不是在函数调用时产生、在函数执行完毕时消失。即使在对外部变量赋值的函数返回后，这些变量仍将保持原来的值不变。

外部变量必须定义在所有函数之外，且只能定义一次，定义后编译程序将为它分配存储单元。在每个需要访问外部变量的函数中，必须声明相应的外部变量，此时说明其类型。声明时可以用 extern 语句显式声明，也可以通过上下文隐式声明。
```

````ad-note
title:变量声明和变量替换
```
#define MAXLINE 2
int MAXLINE 2
```

````

````ad-note
title:颠倒字符串顺序
```
void reverse(char s[]) { // 记一下这个倒序
int length = strlen(s);
for (int i = 0, j = length - 1; i < j; ++i, --j) 
{
		char temp = s[i];
		s[i] = s[j];
		s[j] = temp;
	}
}
```
````

```ad-note
title:扩展名
后缀名.h约定为头文件名的扩展名。
```

```ad-note
title:定义与声明
“定义”表示创建变量或分配存储单元，而“声明”指的是说明变量的性质，但并不分配存储单元。
```

`````ad-note
title:for循环
```C
for (初始化语句; 条件语句; 迭代语句) {
    循环体（循环内容）
}
```
`````
### 第二章 类型、运算符与表达式
```ad-note
title:基本数据类型
char 字符型，占用一个字节，可以存放本地字符集中的一个字符
int 整型，通常反映了所用机器中整数的最自然长度
float 单精度浮点型
double 双精度浮点型
```

```ad-note
title:ANSI C语言中的全部转义字符序列
|   |   |
|---|---|
|`\a`|响铃符|
|`\b`|回退符|
|`\f`|换页符|
|`\n`|换行符|
|`\r`|回车符|
|`\t`|横向制表符|
|`\v`|纵向制表符|
|`\\`|反斜杠|
|`\?`|问号|
|`\'`|单引号|
|`\"`|双引号|
|`\ooo`|八进制数|
|`\xhh`|十六进制数|
字符常量'\0'表示值为 0 的字符，也就是空字符（null）。我们通常用'\0'的形式代替 0， 以强调某些表达式的字符属性，但其数字值为 0。
```

```ad-note
title:字符常量与仅包含一个字符的字符串
'x'与"x"是不同的。 前者是一个整数，其值是字母 x 在机器字符集中对应的数值（内部表示值）；后者是一个包含 一个字符（即字母 x）以及一个结束符'\0'的字符数组。
```

```ad-note
title:强制类型转换
在任何表达式中都可以使用一个称为强制类型转换的一元运算符强制进行显式类 型转换。在下列语句中，表达式将按照上述转换规则被转换为类型名指定的类型：

`(类型名) 表达式`

我们可以这样来理解强制类型转换的准确含义：在上述语句中，表达式首先被赋值给类型名 指定的类型的某个变量，然后再用该变量替换上述整条语句。例如，库函数 sqrt 的参数为 double 类型，如果处理不当，结果可能会无意义（sqrt 在<math.h>中声明）。因此，如果 n 是整数，可以使用

`sqrt((double) n)`

在把 n 传递给函数 sqrt 之前先将其转换为 double 类型。注意，强制类型转换只是生成一 个指定类型的 n 的值，n 本身的值并没有改变。强制类型转换运算符与其它一元运算符具有相 同的优先级，表 2-1 对运算符优先级进行了总结。
```

```ad-note
title:自增运算符与自减运算符
++与--这两个运算符特殊的地方主要表现在：它们既可以用作前缀运算符（用在变量前面，如++n）。也可以用作后缀运算符（用在变量后面，如n++）。在这两种情况下，其效果都是将变量n的值加1。
但是，它们之间有一点不同。表达式++n先将n的值递增1，然后再使用变量n的值，而表达式n++则是先使用变量n的值，然后再将n的值递增1。也就是说，对于使用变量n的值的上下文来说，++n和n++的效果是不同的。如果n的值为5，那么
`x=n++;`
执行后的结果是将x的值置为5，而
`x=++n;`
将x的值置为6。
```
> 这两条语句执行完成后，变量 n 的值都是 6。
> 自增与自减运算符只能作用于 变量，类似于表达式(i+j)++是非法的。
> **j++相当于在下面新开一行，++j相当于在上面新开一行**

```ad-note
title:操作运算符
|  符号 |  含义 |
|---|---|
|`&`|按位与（AND）|
|`\|`|按位或（OR）|
|`^`|按位异或（XOR）|
|`<< `|左移|
|`>> `|右移|
|`~`|按位求反（一元运算符）|
```
> 按位与操作是比较两个数字的每一个位，如果两位都是1，则结果为1，否则结果为0。
> 按位或操作是比较两个数字的每一个位，如果其中一位是1，则结果为1，否则结果为0。
> 按位异或运算符^当两个操作数的对应位不相同时将该位设置为 1，否则，将该位设置为0。
> 按位异或运算符^当两个操作数的对应位不相同时将该位设置为 1，否则，将该位设置为0。表达式 x << 2 将把 x 的值左移 2 位，右边空出的 2 位用 0 填补，该表达式等价于对左操作数乘以 4
> 一元运算符~用于求整数的二进制反码，即分别将操作数各二进制位上的 1 变为 0，0 变 为 1。

````ad-note
title:条件表达式，三元运算符
条件表达式（使用三元运算符“? :”）提 供了另外一种方法编写这段程序及类似的代码段，在表达式
`expr1 ? expr2 : expr3`
中，首先计算 expr1，如果其值不等于 0（为真），则计算 expr2 的值，并以该值作为条件 表达式的值，否则计算 expr3 的值，并以该值作为条件表达式的值。expr2 与 expr3 中只 能有一个表达式被计算。因此，以上语句可以改写为：
```C
z = (a > b) ? a : b; /* z = max(a, b) */
```
````
> 类似np.where(expr1, expr2, expr3)

### 第三章 控制流
````ad-note
title:if-else
```C
if (表达式) 
	语句 
else if (表达式)
	语句 
else if (表达式)
	语句 
else
	语句
```
````
> 语句用分号结尾
> 这里每个else与最近的前一个没有else配对的if进行匹配。如果没有花括号，在多if或嵌套循环的时候容易出错
> 注意：缩进不会改变else的匹配逻辑
> 这种 if 语句序列是编写多路判定最常用的方法。其中的各表 达式将被依次求值，一旦某个表达式结果为真，则执行与之相关的语句，并终止整个语句序 列的执行
> 最后一个 else 部分用于处理“上述条件均不成立”的情况或默认情况，也就是当上面各 条件都不满足时的情形

````ad-note
title:switch语句
```C
switch (表达式) {
	case 常量表达式: 语句序列 
	case 常量表达式: 语句序列 
	default: 语句序列
}
```
````
> 如果某个分支与表达式的值匹配， 则从该分支开始执行。各分支表达式必须互不相同。如果没有哪一分支能匹配表达式，则执 行标记为 default 的分支。default 分支是可选的。如果没有 default 分支也没有其它分 支与表达式的值匹配，则该 switch 语句不执行任何动作。各分支及 default 分支的排列次序是任意的。
> 跳出 switch 语句最常用的方法是使用 break 语句与 return 语句。break 语句还可强制控制从 while、for 与 do 循环语句中立即退出。
> 作为一种良好的程序设计风格，在 switch 语句最后一个分支（即 default 分支）的后 面也加上一个 break 语句。这样做在逻辑上没有必要，但当我们需要向该 switch 语句后添 加其它分支时，这种防范措施会降低犯错误的可能性。

````ad-note
title:for和while循环
```C
for 循环语句; 
for (表达式 1; 表达式 2; 表达式 3) 
	语句
```
等价于下列 while 语句：
```C
表达式 1; 
while (表达式 2) {
	语句
	表达式 3; 
}
```
````
> for(初始条件，循环条件，循环语句)
> while(循环条件){循环内容}
> 从语法角度看，for 循环语句的 3 个组成部分都是表达式。最常见的情况是，表达式 1 与表达式 3 是赋值表达式或函数调用，表达式 2 是关系表达式。这 3 个组成部分中的任何部 分都可以省略，但分号必须保留。如果在 for 语句中省略表达式 1 与表达式 3，它就退化成 了 while 循环语句。如果省略测试条件，即表达式 2，则认为其值永远是真值，因此，下列 for 循环语句：

如果语句中需要执行简单的初始化和变量递增，使用 for 语句更合适一些，它将循环控 制语句集中放在循环的开头，结构更紧凑、更清晰。通过下列语句可以很明显地看出这一点：
```C
for (i = 0; i < n; i++)
	...
```
这是 C 语言处理数组前 n 个元素的一种习惯性用法

`````ad-note
title:shell排序算法
Shell 排序算法是 D. L. Shell 于 1959 年发明的，其基本思想 是：先比较距离远的元素，而不是像简单交换排序算法那样先比较相邻的元素。这样可以快 速减少大量的无序情况，从而减轻后续的工作。被比较的元素之间的距离逐步减少，直到减 少为 1，这时排序变成了相邻元素的互换。
```C
/* shellsort: sort v[0]...v[n-1] into increasing order */ 
void shellsort(int v[], int n) 
{ 
	int gap, i, j, temp;
	for (gap = n/2; gap > 0; gap /= 2)
		for (i = gap; i < n; i++)
			for (j=i-gap; j>=0 && v[j]>v[j+gap]; j-=gap) {
				temp = v[j];
				v[j] = v[j+gap];
				v[j+gap] = temp;
			}
}
```
`````

`````ad-note
title:do-while
```c
do {
	语句}
while (表达式);
```
`````

```ad-note
title:continue和break
1. `break`用来结束循环
2. `continue` 语句是用在循环（例如 `for`、`while` 或 `do-while`）中的，它会结束当前的迭代，并直接跳到循环的下一次迭代。如果是在 `for` 循环中，它会跳到增量表达式（第三部分）；在 `while` 或 `do-while` 循环中，它会跳到条件表达式进行判断。
3. 一个单独的分号表示一个空语句，它实际上什么也不做。它可以存在于程序的任何地方，而不仅仅是循环中。
```
> 理解continue是一小段循环内部的break
```C
for (i = 0; i < n; i++)
	if (a[i] < 0) /* skip negative elements */ 
		continue; 
	... /* do positive elements */
```

### 第四章 函数与程序结构
````ad-note
title:函数的定义形式
```C
返回值类型 函数名(参数声明表) 
{ 
	声明和语句 
}
```
````

cc 命令使用“.c”与“.o”这两种扩展名来区分源文件与目标文件。

```ad-note
title:逆波兰表示法
在逆波兰表示法中，所有运算符都跟在操作数的后面。比如，下列中缀表达式：
`(1 – 2) * (4 + 5)`
采用逆波兰表示法表示为：
`1 2 - 4 5 + *`
逆波兰表示法中不需要圆括号，只要知道每个运算符需要几个操作数就不会引起歧义。
```
> 计算器程序的实现很简单。每个操作数都被依次压入到栈中；当一个运算符到达时，从 栈中弹出相应数目的操作数（对二元运算符来说是两个操作数），把该运算符作用于弹出的操 作数，并把运算结果再压入到栈中。例如，对上面的逆波兰表达式来说，首先把 1 和 2 压入 到栈中，再用两者之差-1 取代它们；然后，将 4 和 5 压入到栈中，再用两者之和 9 取代它们。 最后，从栈中取出栈顶的-1 和 9，并把它们的积-9 压入到栈顶。到达输入行的末尾时，把栈顶 的值弹出并打印。

C 语言不允许在一个函数中定义其它函数， 函数本身是“外部的”

```ad-note
title:变量声明declaration和定义definition
外部变量或函数的作用域从声明它的地方开始，到其所在的（待编译的）文件的末尾结束。
如果`int sp = 0;`声明在main下面，那main无法使用该函数
将外部变量的声明与定义严格区分开来很重要。变量声明用于说明变量的属性（主要是 变量的类型），而变量定义除此以外还将引起存储器的分配。
```
> 如果要在外部变量的定义之前使用该变量，或者外部变量的定义与变量的使 用不在同一个源文件中，则必须在相应的变量声明中强制性地使用关键字 extern
> extern是声明，说明变量在其他地方被定义

```C
extern int i; //声明，不是定义 
int i; //声明，也是定义，未初始化
```
如果将下列语句放在所有函数的外部：
```C
int sp; 
double val[MAXVAL];
```
那么这两条语句将定义外部变量 sp 与 val，并为之分配存储单元，同时这两条语句还可以作 为该源文件中其余部分的声明。而下面的两行语句：
```C
extern int sp; 
extern double val[];
```
为源文件的其余部分声明了一个 int 类型的外部变量 sp 以及一个 double 数组类型的外部 变量 val（该数组的长度在其它地方确定），但这两个声明并没有建立变量或为它们分配存储单元。

```ad-note
title:头文件
把源程序.c的内容放在头文件.h，这样在需要使用该头文件时`#include`指令就可以把他们包含进来
![[Pasted image 20230927214444.png]]
```

```ad-note
title:静态变量
static
```

```ad-note
title:寄存器
`register`声明告诉电脑，其对应变量使用频率高，放在寄存器中
只适用于自动变量和函数的形式参数
```

```ad-note
title:C预处理器
从概念上讲，预处理器是编译过程中单独执行的第一个步骤。
两个最常用的预处理器指令是：`#include` 指令（用于在编译期间把指定文 件的内容包含进当前文件中）和`#define` 指令（用任意字符序列替代一个标记）。
```
> 源文件中形如`#include "文件名"`或`#include <文件名>`的行都将被替换为由文件名指定的文件的内容。

```ad-note
title:宏定义
`#define 名字 替换文本`是一种最简单的宏替换——后续所有出现名字记号的地方都将被替换为替换文本。
```
> 替换文本可以是任意的，例如`#define forever for (;;)`语句为无限循环定义了一个新名字 forever。
> 宏比函数快，省区函数调用时间
> 可以通过`#undef` 指令取消名字的宏定义，这样做可以保证后续的调用是函数调用，而不 是宏调用

宏定义也可以带参数，这样可以对不同的宏调用使用不同的替换文本。例如，下列宏定 义定义了一个宏 max：
```C
#define max(A, B) ((A) > (B) ? (A) : (B))
```
使用宏 max 看起来很像是函数词用，但宏调用直接将替换文本插入到代码中。形式参数（在 此为 A 或 B）的每次出现都将被替换成对应的实际参数。因此，语句：
```C
x = max(p+q, r+s);
```
将被替换为下列形式：
```C
x = ((p+q) > (r+s) ? (p+q) : (r+s));
```
如果对各种类型的参数的处理是一致的，则可以将同一个宏定义应用于任何数据类型， 而无需针对不同的数据类型需要定义不同的 max 函数。

形式参数不能用带引号的字符串替换。但是，如果在替换文本中，参数名以#作为前缀则 结果将被扩展为由实际参数替换该参数的带引号的字符串。例如，可以将它与字符串连接运 算结合起来编写一个调试打印宏：
```C
#define dprint(expr) printf(#expr " = %g\n", expr) 
```
使用语句
```C
dprint(x/y)
``` 
调用该宏时，该宏将被扩展为：
```C
printf("x/y" " = &g\n", x/y);
```
其中的字符串被连接起来了，这样，该宏调用的效果等价于
```C
printf("x/y = &g\n", x/y);
```

```ad-note
title:预处理器运算符`##`
预处理器运算符`##`为宏扩展提供了一种连接实际参数的手段。如果替换文本中的参数与`##`相邻，则该参数将被实际参数替换，`##`与前后的空白符将被删除，并对替换后的结果重新扫描。例如，下面定义的宏 paste 用于连接两个参数
`#define paste(front, back) front ## back` 
因此，宏调用 paste(name, 1)的结果将建立记号 name1。
```

`````ad-note
title:条件包含
例如，为了保证 hdr.h 文件的内容只被包含一次，可以将该文件的内容包含在下列形式的条件语句中： 
```C
#if !defined(HDR) 
#define HDR 
/* hdr.h 文件的内容放在这里 */ 
#endif
```
第一次包含头文件 hdr.h 时，将定义名字 HDR；此后再次包含该头文件时，会发现该名字已 经定义，这样将直接跳转到#endif 处。类似的方式也可以用来避免多次重复包含同一文件。 如果多个头文件能够一致地使用这种方式，那么，每个头文件都可以将它所依赖的任何头文 件包含进来，用户不必考虑和处理头文件之间的各种依赖关系。
C 语言专门定义了两个预处理语句#ifdef 与#ifndef，它们用来测试某个名字是否已经 定义。上面有关#if 的第一个例子可以改写为下列形式：
```C
#ifndef HDR 
#define EDR 
/* hdr.h 文件的内容放在这里 */ 
#endif
```
``````

### 第五章
````ad-note
title:指针与地址
一元运算符`&`可用于取一个对象的地址，因此，下列语句：
```C
p = &c;
```
将把 c 的地址赋值给变量 p，我们称 p 为“指向”c 的指针。地址运算符`&`只能应用于内存中 的对象，即变量与数组元素。它不能作用于表达式、常量或 register 类型的变量。
一元运算符`*`是间接寻址或间接引用运算符。当它作用于指针时，将访问指针所指向的对 象。
我们在这里假定 x 与 y 是整数，而 ip 是指向 int 类型的指针，下面的代码段说明了如 何在程序中声明指针以及如何使用运算符&和*：

```C
int x = 1, y = 2, z[10];
int *ip; /* ip is a pointer to int */
ip = &x; /* ip now points to x */
y = *ip; /* y is now 1 */
*ip = 0; /* x is now 0 */
ip = &z[0]; /* ip now points to z[0] */
```
````
> 数组名代表的就是该数组开始的第一个元素的地址
> `&a[i]`等价于`a+i`

```ad-note
title:指针与函数参数
函数中直接更改参数变量只会变动副本，需要传入变量的指针，并通过指针间接访问
```
> 指针参数使得被调用函数能够访问和修改主调函数中对象的值。

```ad-note
title:有效的指针运算
有效的指针运算包括相同类型指针之间的赋值运算；指针同整数之间的加法或减法运算； 指向相同数组中元素的两个指针间的减法或比较运算；将指针赋值为 0 或指针与 0 之间的比 较运算。其它所有形式的指针运算都是非法的，例如两个指针间的加法、乘法、除法、移位 或屏蔽运算；指针同 float 或 double 类型之间的加法运算；不经强制类型转换而直接将指 向一种类型对象的指针赋值给指向另一种类型对象的指针的运算（两个指针之一是 void * 类型的情况除外）。
```