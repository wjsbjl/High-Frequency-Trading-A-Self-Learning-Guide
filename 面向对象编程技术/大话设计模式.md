- 概括
	- 核心是把想做的事抽象成类
		- 类是最精简的单位，不一定要小，更多的是具有代表性。比如结算，不打折/打折/满减/送积分，抽象成四类，这是工厂思维
		- 进一步地，怎么建立抽象类之间的关系，把未实现的类放进去，这是策略思维
- 细节
	- 可维护，可复用，可扩展，灵活性好
	- 通过封装、继承、多态降低程序耦合度
	- 策略模式（strategy），定义父类，父类不设置具体实现，提取子类的共性，优化单元测试。子类是具体实现，继承后写之前pass掉的函数。==定义的算法执行的是相同的工作，只是实现不同。可以用相同方式调用，减少算法类与使用算法类之间的耦合。==
	- 单一职责原则：一个类，应该仅有一个引起它变化的原因。如果想到多于一个动机改变一个类，那就应该考虑分离。例如涉及俄罗斯方块，分离显示界面和游戏逻辑
	- 开放-封闭原则（The Open-Closed Principle, OCP），不能修改，但可扩展。目标是面对需求不用改代码，而是增加子类。e.g.加法运算变加减乘除，扩展成四个运算子类，运算父类是两个数和运算得到一个数。==是设计模式的核心，权衡拒绝不成熟的抽象和抽象比较困难==
	- 强内聚、松耦合。CPU只要定义好借口，内部再复杂也不用公开，只要主板预留与CPU针脚相同的插槽就可以了。对比之下收音机耦合过度，就一个主板放在一起
	- 依赖倒转原则。抽象不应该依赖细节，细节应该依赖于抽象。针对接口编程，而不是针对实现编程。
		- 里氏代换原则，子类必须能代替它们的父类（子类能执行父类的功能）
	- 装饰模式（Decorator），类似python里的[[装饰器]]，目标是在不修改对象或函数本身的情况下动态地添加或增强其功能，==为已有功能动态地添加更多功能==，区分类的核心功能和装饰功能。
	- 代理模式（Proxy），为其他对象提供一种代理，以控制对这个对象的访问。感觉是内部放同父类的类，引用这个类的属性。[[代理模式和装饰模式比较]]